<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>今逢的博客</title>
  
  <subtitle>We Meet Each Other Today.</subtitle>
  <link href="https://lijinfengisrunning.github.io/atom.xml" rel="self"/>
  
  <link href="https://lijinfengisrunning.github.io/"/>
  <updated>2024-04-03T12:18:04.856Z</updated>
  <id>https://lijinfengisrunning.github.io/</id>
  
  <author>
    <name>今逢</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>aitool</title>
    <link href="https://lijinfengisrunning.github.io/2024/04/03/Gemini%20Pro%20Chat%20(chat4ai.top)/"/>
    <id>https://lijinfengisrunning.github.io/2024/04/03/Gemini%20Pro%20Chat%20(chat4ai.top)/</id>
    <published>2024-04-03T12:13:36.313Z</published>
    <updated>2024-04-03T12:18:04.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gemini-Pro-Chat-chat4ai-top"><a href="#Gemini-Pro-Chat-chat4ai-top" class="headerlink" title="Gemini Pro Chat (chat4ai.top)"></a><a href="https://gemini.chat4ai.top/">Gemini Pro Chat (chat4ai.top)</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Gemini-Pro-Chat-chat4ai-top&quot;&gt;&lt;a href=&quot;#Gemini-Pro-Chat-chat4ai-top&quot; class=&quot;headerlink&quot; title=&quot;Gemini Pro Chat (chat4ai.top)&quot;&gt;&lt;/a&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lijinfengisrunning.github.io/2024/04/03/for%E5%BE%AA%E7%8E%AF/"/>
    <id>https://lijinfengisrunning.github.io/2024/04/03/for%E5%BE%AA%E7%8E%AF/</id>
    <published>2024-04-03T11:17:45.271Z</published>
    <updated>2024-04-03T11:17:45.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="1-for里定义的初始量当循环结束时-会被杀死"><a href="#1-for里定义的初始量当循环结束时-会被杀死" class="headerlink" title="1.for里定义的初始量当循环结束时,会被杀死"></a>1.for里定义的初始量当循环结束时,会被杀死</h3><h3 id="2-sout-输出的只能是for方法以外存在的数据类型"><a href="#2-sout-输出的只能是for方法以外存在的数据类型" class="headerlink" title="2.[sout]输出的只能是for方法以外存在的数据类型"></a>2.[sout]输出的只能是for方法以外存在的数据类型</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;for循环&quot;&gt;&lt;a href=&quot;#for循环&quot; class=&quot;headerlink&quot; title=&quot;for循环&quot;&gt;&lt;/a&gt;for循环&lt;/h2&gt;&lt;h3 id=&quot;1-for里定义的初始量当循环结束时-会被杀死&quot;&gt;&lt;a href=&quot;#1-for里定义的初始量当循环结束时</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://lijinfengisrunning.github.io/2024/04/02/%E6%8F%90%E9%AB%98gradle%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
    <id>https://lijinfengisrunning.github.io/2024/04/02/%E6%8F%90%E9%AB%98gradle%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6/</id>
    <published>2024-04-02T12:17:23.268Z</published>
    <updated>2024-04-02T12:17:26.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="提高gradle下载速度"><a href="#提高gradle下载速度" class="headerlink" title="提高gradle下载速度"></a>提高gradle下载速度</h3><h4 id="1-设置腾讯镜像https-mirrors-cloud-tencent-com-gradle-gradle-4-6-all-zip"><a href="#1-设置腾讯镜像https-mirrors-cloud-tencent-com-gradle-gradle-4-6-all-zip" class="headerlink" title="1.设置腾讯镜像https://mirrors.cloud.tencent.com/gradle/gradle-4.6-all.zip"></a>1.设置腾讯镜像<a href="https://mirrors.cloud.tencent.com/gradle/gradle-4.6-all.zip">https://mirrors.cloud.tencent.com/gradle/gradle-4.6-all.zip</a></h4><h4 id="2-进入gradle-wapper更改镜像"><a href="#2-进入gradle-wapper更改镜像" class="headerlink" title="2.进入gradle.wapper更改镜像"></a>2.进入gradle.wapper更改镜像</h4><h4 id="3-确保有符合需要的包-直接起飞"><a href="#3-确保有符合需要的包-直接起飞" class="headerlink" title="3.确保有符合需要的包,直接起飞"></a>3.确保有符合需要的包,直接起飞</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;提高gradle下载速度&quot;&gt;&lt;a href=&quot;#提高gradle下载速度&quot; class=&quot;headerlink&quot; title=&quot;提高gradle下载速度&quot;&gt;&lt;/a&gt;提高gradle下载速度&lt;/h3&gt;&lt;h4 id=&quot;1-设置腾讯镜像https-mirrors-clo</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySql-基础笔记</title>
    <link href="https://lijinfengisrunning.github.io/2024/01/09/Second-Note/"/>
    <id>https://lijinfengisrunning.github.io/2024/01/09/Second-Note/</id>
    <published>2024-01-09T02:14:30.000Z</published>
    <updated>2024-01-09T08:14:05.208Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="建库"><a href="#建库" class="headerlink" title="建库"></a>建库</h1><p>使用数据库<br><strong>USE 数据库名；</strong></p><p>查询表结构<br><strong>DESC 表名；</strong></p><p>查询指定表建表语句<br><strong>SHOW CREATE TABLE 表名</strong></p><hr><h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><p><strong>CREATE TABLE 表名(<br>        字段1  字段1数据类型  COMMENT ‘注释‘，<br>         ···<br>        字段n  字段n数据类型  COMMENT ‘注释‘<br>    )COMMENT 表注释；</strong></p><hr><h1 id="增-删-改-查-属性"><a href="#增-删-改-查-属性" class="headerlink" title="增 删 改 查 [属性]"></a>增 删 改 查 [属性]</h1><p><strong>ALTER TABLE 表名 ADD&#x2F;DROP 字段名 数据类型;增加&#x2F;删除字段</strong></p><p><strong>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度）;修改数据类型</strong></p><p><strong>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 数据类型;修改字段名</strong></p><p><strong>ALTER TABLE 表名 RENAME TO 新表名;修改表名</strong></p><h2 id="操作元组"><a href="#操作元组" class="headerlink" title="操作元组"></a>操作元组</h2><p>插入数据<br><strong>INSERT INTO 表名(字段名，so on) VALUES[与上级一一对应](数据，so on);</strong></p><p>给全部字段添加域<br><strong>iNSERT INTO 表名 VALUES(数据，so on);</strong><br><strong>insert into 表名values(‘’,’’),(‘’,’’);</strong></p><p>删除所有元组[某一元组]<br><strong>DELETE FROM 表名[WHERE 条件];</strong></p><p>修改元组[部分修改]<br><strong>UPDATE 表名 set 更改条件 [WHERE 条件;]</strong></p><p>选择表<br><strong>select * from 表名；</strong></p><h2 id="查询指定字段"><a href="#查询指定字段" class="headerlink" title="查询指定字段"></a>查询指定字段</h2><p><u><strong>[编写顺序][当表名使用别名时，所有字段名要用  别名.字段名 的形式]</strong></u></p><blockquote><p>[SELECT 字段名]</p><blockquote><p>[AS 别名] </p><blockquote><p>[FROM 表名] </p><blockquote><p>[WHERE 关于属性的条件] </p><blockquote><p>[group by 分组字段列表] </p><blockquote><p>[having 分组后条件列表]</p><blockquote><p>[order by 排序字段列表]  </p><blockquote><p>[limit 分页参数];</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p><u><strong>[执行顺序]</strong></u></p><blockquote><p>[FROM 表名] </p><blockquote><p>[WHERE 关于属性的条件] </p><blockquote><p>[group by 分组字段列表] </p><blockquote><p>[having 分组后条件列表] </p><blockquote><p>[select 字段列表] </p><blockquote><p>[order by 排序字段列表] </p><blockquote><p>[limit 分页参数];</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h3 id="WHERE-条件查询"><a href="#WHERE-条件查询" class="headerlink" title="[WHERE 条件查询]"></a><strong>[WHERE 条件查询]</strong></h3><h4 id="分组查询-查询要符合逻辑顺序"><a href="#分组查询-查询要符合逻辑顺序" class="headerlink" title="[分组查询][查询要符合逻辑顺序]"></a><strong>[分组查询]<u>[查询要符合逻辑顺序]</u></strong></h4><ul><li>SELECT [<code>name</code>字段列表] , [AVG(age)分组方式] FROM emp GROUP BY <strong>[<code>name</code>分组字段名要和前置字段列表一致 desc(降序排列)，asc(默认执行升序排列,只能放在 order by 后)]</strong> having [过滤条件是以前置分组方式为基础作为比较条件];</li></ul><blockquote><p>实例： SELECT  COUNT(<em>)  FROM emp where age&gt;&#x3D;18 GROUP BY age HAVING COUNT(</em>)&gt;&#x3D;3;<br>[意思是：查询年龄大于等于18的员工， 通过年龄分组，显示某一组符合条件成员数量大于三的组]</p></blockquote><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="[分页查询]"></a><strong>[分页查询]</strong></h4><ul><li>SELECT 字段列表 FROM 表 LIMIT 起始索引,每页记录数;[起始索引 &#x3D; （查询页码 -1）* 每页记录数] [第一页数据可写为 (limit 每页记录数)]<blockquote><p>实例：SELECT * FROM emp LIMIT 1,1;</p></blockquote></li></ul><p> <strong>[省略重复数据]</strong></p><blockquote><p>SELECT DISTINCT 属性 FROM 表名;</p></blockquote><h4 id="通配符"><a href="#通配符" class="headerlink" title="[通配符]"></a><strong>[通配符]</strong></h4><ul><li>… IN(A,B,C….)   [多选一，第一个符合，则停止]</li><li>… is null;  [不存在]</li><li>… &amp;&amp;….;</li><li>… like _; [匹配单个字符]&#x2F; … like a_b;     [匹配前后为ab的，个数为3的字符]</li><li>… %x；  [匹配最后为‘x’的任意位字符]  &#x2F;… %x%； [匹配包含‘x’的所有字符]&#x2F;.. x%   [匹配开头为‘x’的任意位字符] **</li></ul><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="[聚合函数]"></a><strong>[聚合函数]</strong></h4><ul><li>[统计符合条件的域的数量]<br>select count(条件&#x2F;[字段:记录中域不为空的数量]) from 表名 where 条件；</li><li>[最大]… max()..</li><li>[最小]… min()..</li><li>[和]… sum()..</li><li>[平均]… avg()..</li></ul><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h1><h2 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="[拼接字符串]"></a><strong>[拼接字符串]</strong></h2><ul><li>CONCAT(S1,S2…SN)</li></ul><p> <strong>[转大小写]</strong></p><ul><li>LOWER(STR) UPPER(STR)</li></ul><p> <strong>[左右补写，用pad对str补写，达到n个字符串]</strong></p><ul><li>L&#x2F;RPAD(STR,N,PAD)</li></ul><p> <strong>[去掉头尾空格]</strong></p><ul><li>TRIM[STR]</li></ul><p> <strong>[返回str从start位置的第len长度字符串]</strong></p><ul><li>SUNSTRING(STR,START,LEN)</li></ul><h2 id="舍入函数"><a href="#舍入函数" class="headerlink" title="[舍入函数]"></a>[舍入函数]</h2><ul><li>[向上取整]… CEIL()..</li><li>[向下取整]… floor()..</li><li>[取余]… mod(x，y)..</li><li>[返回0~1随机数]… rand()..</li><li>[求x四舍五入值，保留y位]… round(x，y)..</li><li>[增加指定时间间隔] CURDATE() CURTIME() YEAR(DATE) NOW() MONTH(DATE) DAY(DATE) </li><li>DATE_ADD(date, INTERVAL expected year&#x2F;day&#x2F;any)<br>[日期间隔]</li><li>DATEDIFF(date1，date2)</li></ul><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="[流程函数]"></a><strong>[流程函数]</strong></h2><ul><li>value为真时返回T，否则返回T<blockquote><p>IF(VALUE,’T’,’F’)<br>IFNULL(‘DATE1’,’DATE2’,…)<br>CASE WHEN [VALUE] THEN [T]…ELSE [DEFAULT] END;<br>[当expected与value相等时，返回T]<br>CASE [EXPECTED] WHEN [VALUE] THEN [T]…ELSE [DEFAULT] END;</p></blockquote></li></ul><hr><h1 id="创建在某一主机访问数据库的用户"><a href="#创建在某一主机访问数据库的用户" class="headerlink" title="创建在某一主机访问数据库的用户"></a><strong>创建在某一主机访问数据库的用户</strong></h1><p><strong>[创建用户]</strong></p><ul><li>CREATE USER ‘[用户名]‘@’[主机名]&#x2F;[%(任意主机)]’ IDENTIFIED by ‘[密码]’;</li></ul><p><strong>[修改用户密码]</strong></p><ul><li>ALTER USER ‘[用户名]‘@’[主机名]&#x2F;[%(任意主机)]’ IDENTIFIED  by ‘[密码]’;</li></ul><p><strong>[删除用户]</strong></p><ul><li>drop USER ‘[用户名]‘@’[主机名]&#x2F;[%(任意主机)]’</li></ul><p><strong>[查询用户权限]</strong></p><ul><li>SHOW GRANTs for ‘[用户名]‘@’[主机名]&#x2F;[%(任意主机)]’;<br><strong>[授权用户权限]</strong></li><li>GRANT ALL[所有权限]&#x2F;select[查询]&#x2F;insert[插入]&#x2F;alter[修改表]&#x2F;delete删除&#x2F;update[修改数据]&#x2F;drop[清库表视图]&#x2F;create[建库表] ON 库名.表名 TO ‘[用户名]‘@’[主机名]&#x2F;[%(任意主机)]’;<br><strong>[撤销权限]</strong></li><li>REVOKR [权限列表] ON 库名.表名  FROM  ‘[用户名]‘@’[主机名]&#x2F;[%(任意主机)]’;</li></ul><hr><h1 id="外键-只有inniDB支持，同时可以通过触发器建立"><a href="#外键-只有inniDB支持，同时可以通过触发器建立" class="headerlink" title="[外键][只有inniDB支持，同时可以通过触发器建立]"></a><strong>[外键][只有inniDB支持，同时可以通过触发器建立]</strong></h1><h2 id="在建表中"><a href="#在建表中" class="headerlink" title="在建表中"></a>在建表中</h2><blockquote><p>CREATE TABLE -(<br>字段名 字段类型，<br>···<br>CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 主表名(主键名));</p></blockquote><ul><li>–tips–<blockquote><p><u>如果为主键添加默认升序排序，那么在插入数据时默认按顺序插入，并且同时也关联了主键表</u></p></blockquote></li></ul><h2 id="已存在表中"><a href="#已存在表中" class="headerlink" title="已存在表中"></a>已存在表中</h2><p> <strong>[删除外键]</strong></p><ul><li>alter table 表名  drop foreign key 外键名称；</li></ul><p> <strong>[删改外键数据]</strong></p><ul><li>alter table 表名  add CONSTRAINT 外键名 FOREIGN KEY(外键字段名) REFERENCES 主表名(主键名) on update 执行语句 on delete 执行语句 set null[删除时执行null];</li></ul><h2 id="多表连接"><a href="#多表连接" class="headerlink" title="[多表连接]"></a><strong>[多表连接]</strong></h2><ul><li>直接在表内关联外键，同时，子表可以填null，此时在副表中插入数据，会直接关联到子表</li></ul><hr><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="[多表查询]"></a>[多表查询]</h1><ul><li>select * from 表名1，表名2；<blockquote><p>出现父表和子表中，外键约束所有组合，这个过程称为笛卡儿积[表1^表2]</p></blockquote></li><li>[去除方法重复][添加约束条件]<blockquote><p>select * from 表名1，表名2 where 表名1.关联外键&#x3D; 表名2.外键约束;</p></blockquote></li></ul><p> [隐式链接和显示连接区别][内连接]</p><ul><li>select * from 表1 [inner] join 表2  on 表名1.关联外键&#x3D; 表名2.外键约束[条件];<blockquote><p>显式连接可以减少字段的扫描，有更快的执行速度。这种速度优势在3张或更多表连接时比较明显</p></blockquote></li></ul><p> [外连接][包含左右表交集]</p><ul><li>select * from 表1 left&#x2F;right[指代join左边或右边位置] [outer] join 表2  on 表名1.关联外键&#x3D; 表名2.外键约束[条件];</li></ul><p> [自连接][务必使用as别名，否则无法分清原表]</p><ul><li>select * from 表1 [as] [inner] join [as] 表2  on 表名1.关联外键&#x3D; 表名2.外键约束[条件];</li></ul><p> [多表联合查询][表一和表二可以为同一张表，但要注意列数和字段类型必须一致]</p><ul><li>select * from 表1 [where] union [all 去掉“all”代表去重] select * from 表2 [where];</li></ul><hr><h1 id="标量子-列子-元子-查询"><a href="#标量子-列子-元子-查询" class="headerlink" title="[标量子&#x2F;列子&#x2F;元子&#x2F;查询]"></a>[标量子&#x2F;列子&#x2F;元子&#x2F;查询]</h1><blockquote><p>[通过限定括号中表的数据位置来查询另一表的数据]<br>[键的作用在于建立两表数据的关联性和一致性]</p></blockquote><ul><li>SELECT * FROM 表1 WHERE 表1字段名 &#x3D;&#x2F;&gt;&#x2F;&lt; (SELECT 表2字段名 FROM 表2 [WHERE 表2条件]);</li></ul><h2 id="可以返回多行的列查询"><a href="#可以返回多行的列查询" class="headerlink" title="[可以返回多行的列查询]"></a>[可以返回多行的列查询]</h2><ul><li>SELECT * FROM 表1 WHERE 字段名 IN(SELECT 字段名 FROM 表2 WHERE 条件1 OR 条件2);<br> [操作符]</li><li>IN &#x2F;NOT IN&#x2F;SOME[至少有一个符合条件any&#x3D;some]&#x2F;ALL[必须符合所有条件]<blockquote><p>例子：SELECT * FROM 表3 WHERE 字段名 [条件] ANY(SELECT * FROM 表1 WHERE 字段名 IN(SELECT 字段名 FROM 表2 WHERE 条件1 OR 条件2));</p></blockquote></li></ul><p> [行子查询][括号内限定条件必须具有唯一性]</p><ul><li>SELECT * FROM 表1 WHERE 字段名 &#x3D; (SELECT &#x2F; FROM &#x2F; WHERE 条件);</li></ul><p> [表子查询][当字段不同时，按顺序返回，首空返回空，后空不返回]</p><ul><li>SELECT * FROM &#x2F; WHERE (&#x2F;,&#x2F;) in (SELECT &#x2F;,&#x2F; FROM &#x2F; WHERE &#x2F; or &#x2F;);</li></ul><hr><h1 id="执行事务"><a href="#执行事务" class="headerlink" title="[执行事务]"></a>[执行事务]</h1><h2 id="选择并关闭系统变量的自动提交，效果持续到下一次改变系统变量"><a href="#选择并关闭系统变量的自动提交，效果持续到下一次改变系统变量" class="headerlink" title="[选择并关闭系统变量的自动提交，效果持续到下一次改变系统变量]"></a>[选择并关闭系统变量的自动提交，效果持续到下一次改变系统变量]</h2><ul><li>select @@autocommit;</li><li>set @@autocommit &#x3D; 0;</li></ul><p> [开启事务，效果持续到下次提交]</p><ul><li>start transaction;<br> [提交变动]</li><li>commit;<br> [撤销执行，并提交]</li><li>rollback;</li></ul><p> set [session(当前库表)&#x2F;global(目标库表)] transaction isolation level [隔离等级]</p><h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="[事务并发问题]"></a>[事务并发问题]</h2><ul><li><p>1，脏读 READ COMMITED</p><blockquote><p>同时操作表&#x2F;库时，用户一进行查询，未查到，进行插入<br>此时用户2进行查询同一值，会读取到用户1正在插入但未commit的值<br>隐患：若用户1最后进行rollback，则用户2查到的是一个错误的值</p></blockquote></li><li><p>2，不可重复读 REPEATABLE READ</p><blockquote><p>用户2在用户1开启事务的第一次查询和第二次查询之间，将查询的值进行了更新，导致用户1两次查询的值不一样<br>但开启指令以后，在用户1未提交[commit]前，查询的值并不会改变</p></blockquote></li><li><p>3，幻读  SERIALIZABLE</p><blockquote><p>用户1 2均处于未提交状态，当1查询以后，数据库报空<br>此时1和2同时进行数据库插入，2成功但1显示该数据已存在<br>此时在进行查询，仍然查寻不出来，此为幻读<br>当提高隔离级别后，在一方开启事务查询时，另一方会无法提交任何更改表的操作</p></blockquote></li></ul><hr><h1 id="视图"><a href="#视图" class="headerlink" title="[视图]"></a>[视图]</h1><blockquote><p>基于查询语句创建的虚拟表，sql语句与基本表相同，只不过将[table]换为[view]，正是由于定义，操作尽量避免[更新]，即使更新，也只是涉及可操作的单条数据；可以基于视图创建视图</p></blockquote><hr><h1 id="范式"><a href="#范式" class="headerlink" title="[范式]"></a>[范式]</h1><ul><li><p>参考链接+强烈推荐[<a href="https://www.bilibili.com/video/BV1Jb4y1C7Ac/?spm_id_from=333.788.recommend_more_video.-1&vd_source=65ae676e3a894768bee5d2513c0ec5b4%5D">https://www.bilibili.com/video/BV1Jb4y1C7Ac/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=65ae676e3a894768bee5d2513c0ec5b4]</a></p></li><li><p><u>在规范范式时，先区分主属性和非主属性，这一部分一般是不可重复的、可作为主码和候选码的</u></p></li><li><p>1NF[第一范式]</p><blockquote><p>域必须独立存在，不能含有集合</p></blockquote></li><li><p>2NF[第二范式]</p><blockquote><p>在第一范式基础上，消除能成为主码的候选码彼此间的依赖，即将候选码分裂出去，形成独立的表，使范式完全依赖候选码</p></blockquote></li><li><p>3NF[第三范式]</p><blockquote><p>在第二范式基础上，消除传递依赖，即，两个或多个属性之间没有直接依赖关系，必须通过某‘中介’产生联系</p></blockquote></li><li><p>BCNF[巴斯-科德范式]</p><blockquote><p>前者基础上，消除主码对于候选码的产生函数依赖</p></blockquote></li><li><p>4NF[第四范式]</p><blockquote><p>消除多码依赖，即每个非主属性码只与它关联的主码产生依赖，这个过程中没有别的非主属性码</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;建库&quot;&gt;&lt;a href=&quot;#建库&quot; class=&quot;headerlink&quot; title=&quot;建库&quot;&gt;&lt;/a&gt;建库&lt;/h1&gt;&lt;p&gt;使用数据库&lt;br&gt;&lt;strong&gt;USE 数据库名；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询表结构&lt;br&gt;&lt;strong&gt;DESC </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="https://lijinfengisrunning.github.io/2024/01/06/First-Note/"/>
    <id>https://lijinfengisrunning.github.io/2024/01/06/First-Note/</id>
    <published>2024-01-06T09:56:21.000Z</published>
    <updated>2024-01-09T02:27:17.864Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-部署环境"><a href="#1-部署环境" class="headerlink" title="1. 部署环境"></a>1. 部署环境</h3><p>下载<a href="https://nodejs.org/en " target="_blank">node.js</a>和<a href="https://git-scm.com/book/zh/" target="_blank">git</a><br></p><hr><h3 id="2-配置镜像"><a href="#2-配置镜像" class="headerlink" title="2. 配置镜像"></a>2. 配置镜像</h3><p>管理员模式下，终端下载 <code>cnpm</code>:<br>输入<code>npm install -g cnpm --registry=<a href="https://registry.npm.taobao.orgc/">https://registry.npm.taobao.orgc</a></code></p><hr><h3 id="3-安装框架"><a href="#3-安装框架" class="headerlink" title="3. 安装框架"></a>3. 安装框架</h3><p>建<code>hexo</code>文件，在该文件目录下，右键打开<CODE>git bash</CODE></p><p>分别输入且回车<br><CODE>npm install hexo-cli -g<br>hexo init blog<br>cd blog<br>npm install<br>hexo server</CODE><br>此时可以使用<a href="http://localhost:4000/">http://localhost:4000/</a>在本机访问HEXO个人博客<br>关闭服务器使用<code><kbd>ctrl+c</kbd></code></p><hr><h3 id="4-关联GITHUB"><a href="#4-关联GITHUB" class="headerlink" title="4. 关联GITHUB"></a>4. 关联<A href="https://github.com/" target="_blank">GITHUB</A></h3><p>在GitHub用户页面，新建 <strong>github用户名.github.io</strong> 的仓库<br> <code>vim _config.yml<br>  type: git<br>  repo: &#123;[github]->[repository]->[code]->[ssh/https]->替换本行&#125;<br>  branch: master</code></p><hr><h3 id="5-启动博客"><a href="#5-启动博客" class="headerlink" title="5. 启动博客"></a>5. 启动博客</h3><p><code>hexo g<br>cnpm install --save hexo-deployer-git<br>hexo d</code><br>若无报错，从<strong>github用户名.github.io</strong> 即可访问！</p><hr><h3 id="6-出现报错"><a href="#6-出现报错" class="headerlink" title="6. 出现报错"></a>6. 出现报错</h3><p>配置<code>git config --global user.name "yourname"<br>git config --global user.email“<a href="mailto:&#121;&#111;&#x75;&#114;&#x40;&#x65;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#121;&#111;&#x75;&#114;&#x40;&#x65;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;</a>"<br></code>注意：<strong>yourname</strong>是你要设置的名字，<strong>your@email</strong>是你要设置的邮箱。<br>删除 <strong>.ssh</strong> 文件夹（直接搜索该文件夹）下的<strong>known_hosts</strong>（手动删除即可，不需要git）<br>输入<br><code>ssh-keygen -t rsa -c "<a href="mailto:&#101;&#109;&#x61;&#105;&#108;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;">&#101;&#109;&#x61;&#105;&#108;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;</a>"</code><br>然后一路确定<br>然后系统会自动在.ssh文件夹下生成两个文件，<strong>id_rsa和id_rsa.pub</strong><br>用记事本打开<strong>id_rsa.pub</strong>,将全部的内容复制<br>返回<strong>gitgub</strong>，进入<strong>setting</strong>，找到<strong>ssh</strong><br>将刚刚复制的粘贴进<strong>key</strong>中<br>输入<code>add ssh key</code><br>在<strong>git</strong>中输入<br><code>ssh -T <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;</a></code><br>输入<strong>yes</strong><br>重复<strong>5.</strong></p><hr><h3 id="7-没有生成id-rsa和id-rsa-pub"><a href="#7-没有生成id-rsa和id-rsa-pub" class="headerlink" title="7.没有生成id_rsa和id_rsa.pub"></a>7.没有生成<strong>id_rsa和id_rsa.pub</strong></h3><p>则在该目录下使用<strong>git</strong>执行<br><code>ssh-keygen -o</code><br>重复<strong>add ssh key</strong></p><hr><h3 id="8-参考链接"><a href="#8-参考链接" class="headerlink" title="8.参考链接"></a>8.参考链接</h3><p><a href="https://blog.csdn.net/jingtingfengguo/article/details/51892864">https://blog.csdn.net/jingtingfengguo/article/details/51892864</a><br><a href="https://blog.csdn.net/Angelalcot/article/details/122359433">https://blog.csdn.net/Angelalcot/article/details/122359433</a><br><a href="https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.337.search-card.all.click</a><br><a href="https://blog.cuijiacai.com/blog-building/">https://blog.cuijiacai.com/blog-building/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-部署环境&quot;&gt;&lt;a href=&quot;#1-部署环境&quot; class=&quot;headerlink&quot; title=&quot;1. 部署环境&quot;&gt;&lt;/a&gt;1. 部署环境&lt;/h3&gt;&lt;p&gt;下载&lt;a href=&quot;https://nodejs.org/en &quot; target=&quot;_blank&quot;&gt;n</summary>
      
    
    
    
    
  </entry>
  
</feed>
